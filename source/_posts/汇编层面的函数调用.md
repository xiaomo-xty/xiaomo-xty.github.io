---
title: 汇编层面的函数调用
tags: [目录,汇编,c语言]
copyright: true
toc: true
reward: false
date: 2023-07-27 20:59:33 
---

 函数调用是很好理解也很强大的编程技术，我们也是用了不知道多少次。那如果我们想玩点hack一点的东西，比如搞点寄存器快照，调用一个函数就可以将当前函数执行的状态全都保存下来，并且后续让它可以恢复，典型的`setjmp` 函数，就需要更深入地理解在在汇编语言的视角里，它是如何实现的

<!--more-->

## c语言程序函数调用

```c
//test.c
int add(int a, int b) {
  int c = a+ b;
  return c;
}
int main(void) {
  int a = 1, b = 2;
  int c = add(a, b);
  return 0;
}
```

```bash
gcc test.c -o test
objdump -S test.c > test_dump.txt
```

```asmatmel
0000000000001129 <add>:
    1129:    f3 0f 1e fa              endbr64 
    112d:    55                       push   %rbp
    112e:    48 89 e5                 mov    %rsp,%rbp
    1131:    89 7d ec                 mov    %edi,-0x14(%rbp)
    1134:    89 75 e8                 mov    %esi,-0x18(%rbp)
    1137:    8b 55 ec                 mov    -0x14(%rbp),%edx
    113a:    8b 45 e8                 mov    -0x18(%rbp),%eax
    113d:    01 d0                    add    %edx,%eax
    113f:    89 45 fc                 mov    %eax,-0x4(%rbp)
    1142:    8b 45 fc                 mov    -0x4(%rbp),%eax
    1145:    5d                       pop    %rbp
    1146:    c3                       ret    

0000000000001147 <main>:
    1147:    f3 0f 1e fa              endbr64 
    114b:    55                       push   %rbp
    114c:    48 89 e5                 mov    %rsp,%rbp
    114f:    48 83 ec 10              sub    $0x10,%rsp
    1153:    c7 45 f4 01 00 00 00     movl   $0x1,-0xc(%rbp)
    115a:    c7 45 f8 02 00 00 00     movl   $0x2,-0x8(%rbp)
    1161:    8b 55 f8                 mov    -0x8(%rbp),%edx
    1164:    8b 45 f4                 mov    -0xc(%rbp),%eax
    1167:    89 d6                    mov    %edx,%esi
    1169:    89 c7                    mov    %eax,%edi
    116b:    e8 b9 ff ff ff           call   1129 <add>
    1170:    89 45 fc                 mov    %eax,-0x4(%rbp)
    1173:    b8 00 00 00 00           mov    $0x0,%eax
    1178:    c9                       leave  
    1179:    c3                       ret 
```

可以看到，在进行函数调用后，add函数并不是第一时间直接执行业务指令，而是调整了`%rbp`寄存器

```asmatmel
    112d:    55                       push   %rbp
    112e:    48 89 e5                 mov    %rsp,%rbp
```

另外`call`指令等价于

```asmatmel
push ip
jmp target
```

所以c语言编译而来的程序，函数在执行第一句实际操作的代码之前，(从高地址到低地址)函数栈里已经存放了

- 调用者调用时的ip寄存器内容(返回地址)
- 调用者的rbp寄存器内容(栈基)

## 汇编程序函数调用

汇编函数的调用稍有不同，c语言因为有编译器自动生成，在`call`之后会自动进行

```asmatmel
pushq %rbp
mov %rsp, %rbp
```

操作，借位也会有`ret`指令，但是汇编不同，汇编函数在进行`call`调用后，只有rip寄存器被保存在了栈中，`%rsp` `%rbp`寄存器都还处于是调用者的形状

![31b3a8fc576b77e9270f87d7224d3049](https://cdn.staticaly.com/gh/xiaomo-xty/picturehost@main/img/23/07/27/31b3a8fc576b77e9270f87d7224d3049.jpeg)

## c语言内嵌汇编调用

```c
int save(struct Context *cxt) {
    asm volatile
    ("  leaq 8(%%rsp), %%rdx;movq %%rdx, (0)(%0);movq %%rbp, (8)(%0); \
        movq (%%rsp), %%rdx;  \
        movq %%rdx, (16)(%0); \
        movq %%r12, (24)(%0); \
        movq %%r12, (32)(%0); \
        movq %%r14, (40)(%0); \
        movq %%r15, (48)(%0); \
        movq $0, %%rax;       \
        retq"                 \
        ::"d"(cxt)
        :"memory");
}
```

```asmatmel
0000000000001149 <save>:
    1149:    f3 0f 1e fa              endbr64 
    114d:    55                       push   %rbp
    114e:    48 89 e5                 mov    %rsp,%rbp
    1151:    48 89 7d f8              mov    %rdi,-0x8(%rbp)
    1155:    48 8b 45 f8              mov    -0x8(%rbp),%rax
    1159:    48 89 c2                 mov    %rax,%rdx
    115c:    48 8d 54 24 08           lea    0x8(%rsp),%rdx
    1161:    48 89 12                 mov    %rdx,(%rdx)
    1164:    48 89 6a 08              mov    %rbp,0x8(%rdx)
    1168:    48 8b 14 24              mov    (%rsp),%rdx
    116c:    48 89 52 10              mov    %rdx,0x10(%rdx)
    1170:    4c 89 62 18              mov    %r12,0x18(%rdx)
    1174:    4c 89 62 20              mov    %r12,0x20(%rdx)
    1178:    4c 89 72 28              mov    %r14,0x28(%rdx)
    117c:    4c 89 7a 30              mov    %r15,0x30(%rdx)
    1180:    48 c7 c0 00 00 00 00     mov    $0x0,%rax
    1187:    c3                       ret    
    1188:    90                       nop
    1189:    5d                       pop    %rbp
    118a:    c3                       ret    
```

截取了一段仿照`setjmp`写的`save`汇编，并改成内嵌汇编后编译，发现与标准汇编果然不同，还是加上了开头的`push %rbp`和`mov %rsp, %rbp`,自然，原本按照单纯`call`指令的栈帧信息设计的`save`已经失效了，要做一些调整才能正常工作，详见[DIY-setjmp](https://littlesun.cloud/2023/07/27/DIY-setjmp/)
